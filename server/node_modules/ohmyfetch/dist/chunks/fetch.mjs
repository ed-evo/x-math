import destr from 'destr';
import { withBase, withQuery } from 'ufo';

class FetchError extends Error {
  constructor() {
    super(...arguments);
    this.name = "FetchError";
  }
}
function createFetchError(request, error, response) {
  let message = "";
  if (request && response) {
    message = `${response.status} ${response.statusText} (${request.toString()})`;
  }
  if (error) {
    message = `${error.message} (${message})`;
  }
  const fetchError = new FetchError(message);
  Object.defineProperty(fetchError, "request", { get() {
    return request;
  } });
  Object.defineProperty(fetchError, "response", { get() {
    return response;
  } });
  Object.defineProperty(fetchError, "data", { get() {
    return response && response.data;
  } });
  return fetchError;
}

const payloadMethods = new Set(Object.freeze(["PATCH", "POST", "PUT", "DELETE"]));
function isPayloadMethod(method = "GET") {
  return payloadMethods.has(method.toUpperCase());
}
function isJSONSerializable(val) {
  if (val === void 0) {
    return false;
  }
  const t = typeof val;
  if (t === "string" || t === "number" || t === "boolean" || t === null) {
    return true;
  }
  if (t !== "object") {
    return false;
  }
  if (Array.isArray(val)) {
    return true;
  }
  return val.constructor && val.constructor.name === "Object" || typeof val.toJSON === "function";
}
const textTypes = /* @__PURE__ */ new Set([
  "image/svg",
  "application/xml",
  "application/xhtml",
  "application/html"
]);
const jsonTypes = /* @__PURE__ */ new Set(["application/json", "application/ld+json"]);
function detectResponseType(_contentType = "") {
  if (!_contentType) {
    return "json";
  }
  const contentType = _contentType.split(";").shift();
  if (jsonTypes.has(contentType)) {
    return "json";
  }
  if (textTypes.has(contentType) || contentType.startsWith("text/")) {
    return "text";
  }
  return "blob";
}

function setHeader(options, _key, value) {
  const key = _key.toLowerCase();
  options.headers = options.headers || {};
  if ("set" in options.headers) {
    options.headers.set(key, value);
  } else if (Array.isArray(options.headers)) {
    const existingHeader = options.headers.find(([header]) => header.toLowerCase() === key);
    if (existingHeader) {
      existingHeader[1] = value;
    } else {
      options.headers.push([key, value]);
    }
  } else {
    const existingHeader = Object.keys(options.headers).find((header) => header.toLowerCase() === key);
    options.headers[existingHeader || key] = value;
  }
}
function createFetch({ fetch }) {
  function onError(request, opts, error, response) {
    if (opts.retry !== false) {
      const retries = typeof opts.retry === "number" ? opts.retry : isPayloadMethod(opts.method) ? 0 : 1;
      if (retries > 0) {
        return $fetchRaw(request, {
          ...opts,
          retry: retries - 1
        });
      }
    }
    const err = createFetchError(request, error, response);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(err, $fetchRaw);
    }
    throw err;
  }
  const $fetchRaw = async function $fetchRaw2(request, opts = {}) {
    if (typeof request === "string") {
      if (opts.baseURL) {
        request = withBase(request, opts.baseURL);
      }
      if (opts.params) {
        request = withQuery(request, opts.params);
      }
      if (opts.body && isPayloadMethod(opts.method)) {
        if (isJSONSerializable(opts.body)) {
          opts.body = JSON.stringify(opts.body);
          setHeader(opts, "content-type", "application/json");
          setHeader(opts, "accept", "application/json");
        }
      }
    }
    const response = await fetch(request, opts).catch((error) => onError(request, opts, error, void 0));
    const responseType = opts.parseResponse ? "json" : opts.responseType || detectResponseType(response.headers.get("content-type") || "");
    if (responseType === "json") {
      const data = await response.text();
      const parseFn = opts.parseResponse || destr;
      response.data = parseFn(data);
    } else {
      response.data = await response[responseType]();
    }
    return response.ok ? response : onError(request, opts, void 0, response);
  };
  const $fetch = function $fetch2(request, opts) {
    return $fetchRaw(request, opts).then((r) => r.data);
  };
  $fetch.raw = $fetchRaw;
  return $fetch;
}

export { FetchError as F, createFetchError as a, createFetch as c, setHeader as s };
